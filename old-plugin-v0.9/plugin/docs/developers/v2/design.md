# General Plugin Design

This gives an overview of how the classes in the plugin work together, to help
new developers get up to speed.


## The Plugin Starting Point

Everything starts with the `P4Vcs` class and the `META-INF/plugin.xml` file.
These two tell IntelliJ how to connect the plugin into the IDE.  The
`plugin.xml` file mostly defines the UI actions and persistent state classes,
while the `P4Vcs` centralizes the Vcs API behavior.



## Server State and Caching

In order to support limited offline capabilities, as well as enhanced
performance through background server interaction, the plugin maintains a
cache of the server settings in the `CentralCacheManager` class.

The cache maintains a state of the server (`CachedState` instances), along
with pending actions that the user wants to run (generated by
`ServerUpdateActionFactory` instances).

The user actions use a series of enums centralized in `UpdateAction`. 

The `AllClientsState` class marshals the state to disk.

(See [the server communication design doc](server_communication.md) for the
initial design for the caching of the server objects.)


## Version Control Panel

The primary server focal point is the *Local Changes* panel in the IDE Version
Control panel.  This is the heart of where the user interacts with the server.

...


## Low Level Server Interaction

The server connections are contained in the `AuthenticatedServer` class.  This
uses the `ServerAuthenticator` to discover the authentication status and
perform login attempts to the server.  This uses a model of *checking out* a
server to prevent multithreaded usage of a single server connection, and help
identify where those issues appear in the code.

Connections are authenticated (login, auth ticket, etc) with the
authentication status constructed, in the `ServerAuthenticator`.

Commands are executed through the `ServerRunner` class, in order to centralize
exception handling.

The connection state (online, valid) is handled by a `ServerConnection`, which
maintains state for all clients to a single server.  This allows for a project
to maintain multiple clients to a single server with a single online / offline
status for all of them.

The `ServerConnectionManager`maintains all the `ServerConnection` objects.
 
The actual Perforce commands run through the `ClientExec` class, using a
`WithServer` for commands that only require an `IServer` instance, or a
`WithClient` for commands that require a client workspace.

The layer that simplifies the low-level P4 commands to a more API friendly
interface is the `P4Exec2` class.


### Configuration UI

The key exception to the general approach for connections is with the
configuration panels.  These need to create server instances that only exist
to test out a connection to the server, or to find the list of clients owned
by the user in the configuration.  These use the `ConnectionUIConfiguration`
class to run these highly specific commands, without needing to create a
local cache of the server and client information.



## Server Connection Configuration

The server connection is defined through a series of parts, either a `DataPart`
or a `CompositePart`.  These allow for building up the configuration properties
in a `P4ProjectConfigStack`, which creates a mapping between project
directories and their client configuration.

The `P4ProjectConfigComponent` class marshals the user settings for the
connection configuration to disk.

Any logging that's done on the client connection configuration must go through
the `ConfigPropertiesUtil` to ensure proper clensing of the password.



## Alerting The User

Errors are passed to the user in two ways: either through critical errors
in the `AlertManager`, or through `WarningMessage` instances in the
`WarningViewHandler`.



## Localization

All user-facing messages are localized through the `P4Bundle` class and the
`P4Bundle.properties` file.  Logging messages are fine as non-localized.

Be careful with exception messages.  These can be shown to the user, so their
text must be localized where possible.
