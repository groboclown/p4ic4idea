/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.groboclown.idea.p4ic.v2.server;

import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.Ref;
import com.intellij.openapi.vcs.FilePath;
import com.intellij.openapi.vcs.VcsException;
import com.intellij.openapi.vcs.changes.LocalChangeList;
import com.intellij.openapi.vfs.VirtualFile;
import com.perforce.p4java.core.IChangelist;
import com.perforce.p4java.core.IChangelistSummary;
import com.perforce.p4java.core.file.IExtendedFileSpec;
import com.perforce.p4java.core.file.IFileRevisionData;
import com.perforce.p4java.core.file.IFileSpec;
import com.perforce.p4java.impl.mapbased.rpc.func.helper.MD5Digester;
import net.groboclown.idea.p4ic.P4Bundle;
import net.groboclown.idea.p4ic.changes.P4ChangeListId;
import net.groboclown.idea.p4ic.config.ClientConfig;
import net.groboclown.idea.p4ic.config.ServerConfig;
import net.groboclown.idea.p4ic.extension.P4Vcs;
import net.groboclown.idea.p4ic.server.FileSpecUtil;
import net.groboclown.idea.p4ic.server.P4StatusMessage;
import net.groboclown.idea.p4ic.server.exceptions.*;
import net.groboclown.idea.p4ic.v2.changes.P4ChangeListIdImpl;
import net.groboclown.idea.p4ic.v2.changes.P4ChangeListJob;
import net.groboclown.idea.p4ic.v2.changes.P4ChangeListMapping;
import net.groboclown.idea.p4ic.v2.changes.P4CommittedChangeList;
import net.groboclown.idea.p4ic.v2.history.P4AnnotatedLine;
import net.groboclown.idea.p4ic.v2.history.P4FileRevision;
import net.groboclown.idea.p4ic.v2.server.cache.ClientServerRef;
import net.groboclown.idea.p4ic.v2.server.cache.P4ChangeListValue;
import net.groboclown.idea.p4ic.v2.server.cache.state.P4FileSyncState;
import net.groboclown.idea.p4ic.v2.server.cache.state.P4JobState;
import net.groboclown.idea.p4ic.v2.server.cache.state.PendingUpdateState;
import net.groboclown.idea.p4ic.v2.server.cache.state.UserSummaryState;
import net.groboclown.idea.p4ic.v2.server.cache.sync.ClientCacheManager;
import net.groboclown.idea.p4ic.v2.server.connection.*;
import net.groboclown.idea.p4ic.v2.server.connection.ServerConnection.CacheQuery;
import net.groboclown.idea.p4ic.v2.server.connection.ServerConnection.CreateUpdate;
import net.groboclown.idea.p4ic.v2.server.util.FilePathUtil;
import net.groboclown.idea.p4ic.v2.server.util.RemoteFileReader;
import net.groboclown.idea.p4ic.v2.server.util.RootDiscoveryUtil;
import net.groboclown.idea.p4ic.v2.ui.alerts.DisconnectedHandler;
import net.groboclown.p4.simpleswarm.SwarmConfig;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.util.*;
import java.util.Map.Entry;

/**
 * Top-level manager for handling communication with the Perforce server
 * for a single client/server connection.
 * <p/>
 * The owner of this object needs to be aware of config changes; those
 * signal that the server instances are no longer valid.
 * It should listen to {@link net.groboclown.idea.p4ic.v2.events.BaseConfigUpdatedListener#TOPIC_NORMAL} events, which
 * are generated by {@link net.groboclown.idea.p4ic.config.P4ProjectConfigComponent}.
 * <p/>
 * The owner should also only save the state for valid server objects.
 * <p/>
 * It connects to a {@link ServerConnection}.
 */
public class P4Server {
    private static final Logger LOG = Logger.getInstance(P4Server.class);

    private final Project project;
    private final ServerConnection connection;
    private final AlertManager alertManager;
    private final ClientConfig source;

    private boolean valid = true;
    private boolean disposed = false;


    /**
     * Contains data for integrating one file to another file.
     * It specifically has reference data for handling the
     * situation where the source file is on another client
     * in the same server.  It is up to the caller to discover
     * whether the source file is on the same server or not.
     */
    public static final class IntegrateFile {
        private final ClientServerRef sourceClient;
        private final FilePath sourceFile;
        private final FilePath targetFile;

        public IntegrateFile(@NotNull FilePath sourceFile, @NotNull FilePath targetFile) {
            this(null, sourceFile, targetFile);
        }

        public IntegrateFile(@Nullable ClientServerRef sourceClient, @NotNull FilePath sourceFile,
                @NotNull FilePath targetFile) {
            this.sourceClient = sourceClient;
            this.sourceFile = sourceFile;
            this.targetFile = targetFile;
        }

        @NotNull
        public FilePath getSourceFile() {
            return sourceFile;
        }

        @NotNull
        public FilePath getTargetFile() {
            return targetFile;
        }

        @Override
        public String toString() {
            return "Integrate(" + (sourceClient == null
                    ? ""
                    : (sourceClient + "::")
                ) + sourceFile + " -> " + targetFile + ")";
        }
    }




    P4Server(@NotNull final Project project, @NotNull final ClientConfig source)
            throws P4InvalidClientException {
        this.project = project;
        this.alertManager = AlertManager.getInstance();
        this.source = source;
        //this.clientState = AllClientsState.getInstance().getStateForClient(clientServerId);
        this.connection = ServerConnectionManager.getInstance().getConnectionFor(project, source, true);
        connection.postSetup(project);

        // Do not reload the caches early.
    }


    @NotNull
    public Project getProject() {
        return project;
    }


    public boolean isValid() {
        return valid && ! disposed && connection.isValid() &&
                ! project.isDisposed();
    }

    public boolean isDisposed() {
        return disposed;
    }

    public boolean isConnectionValid() {
        return connection.isValid();
    }

    public boolean isWorkingOnline() {
        return isValid() && connection.isWorkingOnline();
    }
    public boolean isWorkingOffline() {
        return !isValid() || connection.isWorkingOffline();
    }

    boolean isSameSource(@Nullable ClientConfig pcs) {
        return source.equals(pcs);
    }


    @NotNull
    public String getClientServerDisplayId() {
        String serverDisplay = source.getClientServerRef().getServerDisplayId();
        String clientDisplay = source.getClientServerRef().getClientName();
        if (clientDisplay == null) {
            return P4Bundle.message("client-server.display.server-only", serverDisplay);
        }
        return P4Bundle.message("client-server.display.server-client", serverDisplay, clientDisplay);
    }

    public void workOffline() {
        if (isValid()) {
            connection.workOffline();
        }
    }

    public void workOnline() {
        if (isValid()) {
            connection.workOnline(project);
        } else {
            LOG.warn("Client " + source + " is invalid, so cannot go online");
        }
    }


    /**
     * This does not perform link expansion (get absolute path).  We
     * assume that if you have a file under a path in a link, you want
     * it to be at that location, and not at its real location.
     *
     * @param file file to match against this client's root directories.
     * @return the directory depth at which this file is in the client.  This is the shallowest depth for all
     *      the client roots.  It returns -1 if there is no match.
     */
    int getFilePathMatchDepth(@NotNull FilePath file) throws InterruptedException {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Finding depth for " + file + " in " + getClientName());
        }
        if (! isValid()) {
            return -1;
        }

        return RootDiscoveryUtil.getFilePathMatchDepth(file,
                source.getProjectSourceDirs(),
                getProjectClientRoots());
    }

    /**
     * The root directories that this perforce client covers in this project.
     * It starts with the client workspace directories, then those are stripped
     * down to just the files in the project, then those are limited by the
     * location of the perforce config directory.
     *
     * @return the actual client root directories used by the workspace,
     *      split by parent directories.
     * @throws InterruptedException if the underlying query is interrupted
     */
    @NotNull
    public List<List<File>> getRoots() throws InterruptedException {
        return RootDiscoveryUtil.getRoots(source.getProjectSourceDirs(),
                getProjectClientRoots());
    }


    /**
     * Returns the client workspace roots limited to the project.  These may be
     * wider than what should be used.
     *
     * @return project-based roots
     * @throws InterruptedException if the underlying query is cancelled.
     */
    @NotNull
    private List<VirtualFile> getProjectClientRoots() throws InterruptedException {
        return connection.cacheQuery(new CacheQuery<List<VirtualFile>>() {
            @Override
            public List<VirtualFile> query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                List<VirtualFile> roots = mgr.getClientRoots(project, alertManager);
                if (roots == null && isWorkingOnline()) {
                    LOG.debug("working online; no roots known for client, so refreshing list");
                    connection.query(project, mgr.createWorkspaceRefreshQuery());
                    roots = mgr.getClientRoots(project, alertManager);
                    if (roots == null) {
                        // TODO determine if this means we should tell the user.
                        LOG.info("Attempted to reload the workspace information, but the workspace roots list is "
                                + "still empty");
                    }
                }
                if (roots == null) {
                    return Collections.emptyList();
                }
                return roots;
            }
        });
    }


    /**
     *
     * @param files files to grab server status
     * @return null if working disconnected, otherwise the server status of the files.
     */
    @Nullable
    public Map<FilePath, IExtendedFileSpec> getFileStatus(@NotNull final Collection<FilePath> files)
            throws InterruptedException {
        if (files.isEmpty()) {
            return Collections.emptyMap();
        }
        if (isWorkingOffline()) {
            LOG.info("Cannot get file status while offline: " + files);
            return null;
        }
        final List<FilePath> filePathList = new ArrayList<FilePath>(files);
        final Iterator<FilePath> iter = filePathList.iterator();
        while (iter.hasNext()) {
            // Strip out directories, to ensure we have a valid mapping
            final FilePath next = iter.next();
            if (next.isDirectory()) {
                iter.remove();
            }
        }

        final List<IFileSpec> fileSpecs;
        try {
            fileSpecs = FileSpecUtil.getFromFilePaths(filePathList);
        } catch (P4Exception e) {
            alertManager.addWarning(project,
                    P4Bundle.message("error.file-status.fetch.title"),
                    P4Bundle.message("error.file-status.fetch", files), e,
                    filePathList);
            return null;
        }
        if (fileSpecs.size() != filePathList.size()) {
            // See bug #152.  This was occurring when the file status returned
            // a list of different length than the original list.  From what I
            // can tell, this is either a bug in the p4 java code, or some paths
            // are getting stripped when they shouldn't
            throw new IllegalStateException("A path was stripped by `getFromFilePaths`: input "
                + filePathList + "; specs " + fileSpecs);
        }

        final List<IExtendedFileSpec> extended = connection.query(project, new ServerQuery<List<IExtendedFileSpec>>() {
            @Nullable
            @Override
            public List<IExtendedFileSpec> query(@NotNull final P4Exec2 exec,
                    @NotNull final ClientCacheManager cacheManager,
                    @NotNull final ServerConnection connection,
                    @NotNull final SynchronizedActionRunner runner,
                    @NotNull final AlertManager alerts)
                    throws InterruptedException {
                try {
                    return exec.getFileStatus(fileSpecs);
                } catch (VcsException e) {
                    alertManager.addWarning(project,
                            P4Bundle.message("error.file-status.fetch.title"),
                            P4Bundle.message("error.file-status.fetch", files), e,
                            filePathList);
                    return null;
                }
            }
        });
        return mapExtendedFileSpecs(filePathList, extended);
    }


    @NotNull
    public Map<IExtendedFileSpec, FilePath> mapSpecsToPath(@NotNull final Collection<IExtendedFileSpec> specs)
            throws InterruptedException {
        if (specs.isEmpty()) {
            return Collections.emptyMap();
        }
        Map<IExtendedFileSpec, FilePath> ret =
                connection.query(project, new ServerQuery<Map<IExtendedFileSpec, FilePath>>() {
                    @NotNull
                    @Override
                    public Map<IExtendedFileSpec, FilePath> query(@NotNull final P4Exec2 exec,
                            @NotNull final ClientCacheManager cacheManager,
                            @NotNull final ServerConnection connection,
                            @NotNull final SynchronizedActionRunner runner,
                            @NotNull final AlertManager alerts)
                            throws InterruptedException {
                        return cacheManager.mapSpecsToPath(specs);
                    }
                });
        if (ret == null) {
            return Collections.emptyMap();
        }
        return ret;
    }



    @Nullable
    private Map<FilePath, IExtendedFileSpec> mapExtendedFileSpecs(
            @Nullable List<FilePath> filePathList,
            @Nullable List<IExtendedFileSpec> extended) {
        if (extended == null) {
            return null;
        }

        Map<FilePath, IExtendedFileSpec> ret = new HashMap<FilePath, IExtendedFileSpec>();

        // should be a 1-to-1 mapping
        if (filePathList != null) {
            // TODO perform better matching
            // Logic is a bit complex; move to another class?
            if (filePathList.size() != extended.size()) {
                StringBuilder sb = new StringBuilder("did not match ");
                sb.append(filePathList).append(" against [");
                for (IExtendedFileSpec extendedFileSpec : extended) {
                    sb
                            .append(" {")
                            .append(extendedFileSpec.getOpStatus()).append(":")
                            .append(extendedFileSpec.getStatusMessage()).append("::")
                            .append(extendedFileSpec.getDepotPath())
                            .append("} ");
                }
                sb.append("]");
                throw new IllegalStateException(sb.toString());
            }
            for (int i = 0; i < filePathList.size(); i++) {
                LOG.info("Mapped " + filePathList.get(i) + " to " + extended.get(i));
                ret.put(filePathList.get(i), extended.get(i));
            }
        } else {
            for (IExtendedFileSpec spec : extended) {
                String path = spec.getClientPathString();
                if (path == null) {
                    // TODO report a better error message than this
                    throw new IllegalStateException("Bad client path in extended spec " + spec);
                }
                ret.put(FilePathUtil.getFilePath(path), spec);
            }
        }
        return ret;
    }



    /**
     * Return all files open for edit (or move, delete, etc) on this client.
     *
     * @return opened files state
     */
    @NotNull
    public Collection<P4FileAction> getOpenFiles() throws InterruptedException {
        return connection.cacheQuery(new CacheQuery<Collection<P4FileAction>>() {
            @Override
            public Collection<P4FileAction> query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                if (isWorkingOnline()) {
                    if (! mgr.hasClientRoots(project)) {
                        LOG.debug("working online; no roots known for client, so refreshing list");
                        connection.query(project, mgr.createWorkspaceRefreshQuery());
                    }
                    connection.query(project, mgr.createFileActionsRefreshQuery());
                }
                return mgr.getCachedOpenFiles();
            }
        });
    }

    @NotNull
    public Collection<UserSummaryState> getUsers()
            throws InterruptedException {
        return connection.cacheQuery(new CacheQuery<Collection<UserSummaryState>>() {
            @Override
            public Collection<UserSummaryState> query(@NotNull ClientCacheManager mgr)
                    throws InterruptedException {
                if (isWorkingOnline()) {
                    connection.query(project, mgr.createUserSummaryRefreshQuery());
                }
                return mgr.getCachedUsers();
            }
        });
    }



    /**
     * Needs to be run immediately.
     *
     * @param files        files to add or  edit
     * @param changelistId changelist id
     */
    public void addFiles(@NotNull final List<VirtualFile> files, final int changelistId) {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Add to " + changelistId + " files " + files);
        }
        if (files.isEmpty()) {
            return;
        }
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                List<PendingUpdateState> updates = new ArrayList<PendingUpdateState>();
                for (VirtualFile file : files) {
                    addPendingUpdateState(updates,
                            mgr.addFile(project, FilePathUtil.getFilePath(file), changelistId));
                }
                return updates;
            }
        });
    }

    /**
     * Needs to be run immediately.
     *
     * @param files files to add or  edit
     * @param changelistId changelist id
     */
    public void addOrEditFiles(@NotNull final List<VirtualFile> files, final int changelistId) {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Add or edit to " + changelistId + " files " + files);
        }
        if (files.isEmpty()) {
            return;
        }
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {

                // TODO For rollback, we can use the internal IDE history to capture what to rollback to.
                // Need to inspect their API around that.


                List<PendingUpdateState> updates = new ArrayList<PendingUpdateState>();
                for (VirtualFile file : files) {
                    addPendingUpdateState(updates, mgr.addOrEditFile(project, FilePathUtil.getFilePath(file), changelistId));
                }
                return updates;
            }
        });
    }

    public void onlyEditFile(@NotNull final VirtualFile file, final int changelistId) {
        // Bug #6
        //   Add/Edit without adding to Perforce incorrectly
        //   then adds the file to Perforce
        // This method is called when a save happens, which can be
        // at any time.  If the save is called on a file which is
        // marked as locally updated but not checked out, this will
        // still be called.  This method should never *add* a file
        // into Perforce - only open for edit.

        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull ClientCacheManager mgr) {
                return singlePendingUpdateState(mgr.editFile(project, file, changelistId));
            }
        });
    }

    public void moveFiles(@NotNull final List<IntegrateFile> files, final int changelistId) {
        if (files.isEmpty()) {
            return;
        }
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                List<PendingUpdateState> ret = new ArrayList<PendingUpdateState>(files.size());
                for (IntegrateFile file : files) {
                    LOG.info("move: " + file);
                    addPendingUpdateState(ret, mgr.moveFile(project, file, changelistId));
                }
                return ret;
            }
        });
    }

    public void integrateFiles(@NotNull final List<IntegrateFile> integrationFiles, final int changelistId) {
        if (integrationFiles.isEmpty()) {
            return;
        }
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                List<PendingUpdateState> ret = new ArrayList<PendingUpdateState>(integrationFiles.size());
                for (IntegrateFile file : integrationFiles) {
                    LOG.info("integrate: " + file);
                    addPendingUpdateState(ret, mgr.integrateFile(file, changelistId));
                }
                return ret;
            }
        });
    }


    public void revertFiles(@NotNull final List<FilePath> files, List<VcsException> exceptions) {
        if (isWorkingOnline()) {
            try {
                revertFilesOnline(files);
            } catch (InterruptedException e) {
                LOG.warn(e);
                exceptions.add(new VcsInterruptedException(e));
            } catch (P4DisconnectedException e) {
                LOG.warn(e);
                exceptions.add(e);
            }
        } else {
            Set<FilePath> unreverted = new HashSet<FilePath>(files);
            try {
                unreverted.removeAll(revertFilesOffline(files));
                if (!unreverted.isEmpty()) {
                    exceptions.add(new OfflineRevertException());
                }
            } catch (InterruptedException e) {
                LOG.warn(e);
                exceptions.add(new VcsInterruptedException(e));
            }
        }
    }


    /**
     * Perform what can be done as an offline revert.
     *
     * @param files files to revert
     * @return the files that were actually reverted.
     */
    @NotNull
    private Collection<FilePath> revertFilesOffline(@NotNull final List<FilePath> files) throws InterruptedException {
        if (files.isEmpty()) {
            return Collections.emptyList();
        }
        return connection.cacheQuery(new CacheQuery<Collection<FilePath>>() {
            @NotNull
            @Override
            public Collection<FilePath> query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                return mgr.revertFilesOffline(files);
            }
        });
    }


    /**
     *
     * @param files files to revert.
     */
    @NotNull
    private MessageResult<List<FilePath>> revertFilesOnline(@NotNull final List<FilePath> files)
            throws InterruptedException, P4DisconnectedException {
        if (files.isEmpty()) {
            return new MessageResult<List<FilePath>>(
                    Collections.<FilePath>emptyList(), Collections.<P4StatusMessage>emptyList());
        }
        validateOnline();

        // TODO this API usage here is not the right way to go about it;
        // the runImmediately needs to be called inside another call (usually cacheQuery,
        // but probably shouldn't be).  It's too easy to mess up this usage pattern.
        return connection.cacheQuery(new CacheQuery<MessageResult<List<FilePath>>>() {
            @Override
            public MessageResult<List<FilePath>> query(@NotNull final ClientCacheManager mgr)
                    throws InterruptedException {
                Ref<MessageResult<List<FilePath>>> ret = new Ref<MessageResult<List<FilePath>>>();
                ServerUpdateAction action = mgr.revertFilesOnline(files, ret);
                if (action != null) {
                    connection.runImmediately(project, action);
                }
                if (ret.isNull()) {
                    return new MessageResult<List<FilePath>>(
                            Collections.<FilePath>emptyList(), Collections.<P4StatusMessage>emptyList());
                }
                return ret.get();
            }
        });
        /* offline version
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                List<PendingUpdateState> ret = new ArrayList<PendingUpdateState>(files.size());
                for (FilePath file : files) {
                    LOG.info("revert: " + file);
                    addPendingUpdateState(ret, mgr.revertFile(file));
                }
                return ret;
            }
        });
        */
    }

    /**
     * For now, the rollback operations can only be done while online.
     *
     *
     * @param files file to revert.
     * @return all files that were reverted
     */
    @NotNull
    public MessageResult<List<FilePath>> revertUnchangedFilesOnline(@NotNull final Collection<FilePath> files,
            final int changelistId)
            throws InterruptedException, P4DisconnectedException {
        if (files.isEmpty()) {
            return new MessageResult<List<FilePath>>(
                    Collections.<FilePath>emptyList(), Collections.<P4StatusMessage>emptyList());
        }
        validateOnline();
        return connection.cacheQuery(new CacheQuery<MessageResult<List<FilePath>>>() {
            @Override
            public MessageResult<List<FilePath>> query(@NotNull final ClientCacheManager mgr)
                    throws InterruptedException {
                Ref<MessageResult<List<FilePath>>> ret = new Ref<MessageResult<List<FilePath>>>();
                ServerUpdateAction action = mgr.revertFilesIfUnchangedOnline(files, changelistId, ret);
                if (action != null) {
                    connection.runImmediately(project, action);
                }
                if (ret.isNull()) {
                    return new MessageResult<List<FilePath>>(
                            Collections.<FilePath>emptyList(), Collections.<P4StatusMessage>emptyList());
                }
                return ret.get();
            }
        });
    }


    @NotNull
    public MessageResult<Collection<FileSyncResult>> synchronizeFilesOnline(@NotNull final Collection<FilePath> files,
            final int revisionNumber, @Nullable final String syncSpec, final boolean force)
            throws InterruptedException, P4DisconnectedException {
        if (files.isEmpty()) {
            return new MessageResult<Collection<FileSyncResult>>(
                    Collections.<FileSyncResult>emptyList(), Collections.<P4StatusMessage>emptyList());
        }
        validateOnline();
        // This operation must be done when called.
        return connection.cacheQuery(new CacheQuery<MessageResult<Collection<FileSyncResult>>>() {
            @Override
            public MessageResult<Collection<FileSyncResult>> query(@NotNull final ClientCacheManager mgr)
                    throws InterruptedException {
                Ref<MessageResult<Collection<FileSyncResult>>> ref = new Ref<MessageResult<Collection<FileSyncResult>>>();
                final ServerUpdateAction update = mgr.synchronizeFilesOnline(files, revisionNumber, syncSpec, force, ref);
                if (update != null) {
                    connection.runImmediately(project, update);
                }
                if (ref.isNull()) {
                    return new MessageResult<Collection<FileSyncResult>>(
                            Collections.<FileSyncResult>emptyList(), Collections.<P4StatusMessage>emptyList());
                }
                return ref.get();
            }
        });
    }

    public Collection<P4ChangeListValue> getOpenChangeLists() throws InterruptedException {
        return connection.cacheQuery(new CacheQuery<Collection<P4ChangeListValue>>() {
            @Override
            public Collection<P4ChangeListValue> query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                if (isWorkingOnline()) {
                    connection.query(project, mgr.createChangeListRefreshQuery());
                }
                return mgr.getCachedOpenedChanges();
            }
        });
    }

    public void deleteChangelist(final int changeListId) {
        if (changeListId == P4ChangeListId.P4_DEFAULT || changeListId == P4ChangeListId.P4_UNKNOWN) {
            return;
        }
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                final PendingUpdateState update = mgr.deleteChangelist(changeListId);
                if (update == null) {
                    return Collections.emptyList();
                }
                return Collections.singletonList(update);
            }
        });
    }

    public void renameChangelist(final int changeListId, final String description) {
        if (changeListId == P4ChangeListId.P4_DEFAULT || changeListId == P4ChangeListId.P4_UNKNOWN) {
            return;
        }
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                PendingUpdateState update = mgr.renameChangelist(changeListId, description);
                if (update == null) {
                    return Collections.emptyList();
                }
                return Collections.singletonList(update);
            }
        });
    }

    /**
     * @param filePaths files to move
     * @param source used to discover which changelist will contain the files.  The changelist
     *               ID isn't necessary to pass in, as this will do discovery in the case of the
     * @param changeListMapping the mapping between p4 changes and the IDEA changes.
     */
    public void moveFilesToChange(@NotNull List<FilePath> filePaths, @NotNull final LocalChangeList source,
            final P4ChangeListMapping changeListMapping) {
        if (! filePaths.isEmpty()) {
            final List<FilePath> filePathCopy = new ArrayList<FilePath>(filePaths);
            connection.queueUpdates(project, new CreateUpdate() {
                @NotNull
                @Override
                public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                    // Because this operation can potentially create a new P4 changelist, and
                    // because the files MUST be assigned to a real changelist number when the
                    // edit occurs, this operation must be run as a single action.  Otherwise,
                    // there'd be the state where a newly associated Perforce changelist number
                    // has files that should move into it, but they still point to the old
                    // (local) changelist number; that would require keeping invalid local
                    // changelists around until the associated files used it, and that would be
                    // a mess to properly detect and clean up.

                    // To add to the mess, this method can be called by the P4ChangelistListener
                    // after P4ChangeProvider causes things to move into the correct changelist.
                    // This can lead to all kinds of terrible performance issues.

                    P4ChangeListId clid = changeListMapping.getPerforceChangelistFor(P4Server.this, source);
                    if (clid != null) {
                        // quick check to see if we already have that file in that changelist.
                        final Collection<P4FileAction> opened = mgr.getCachedOpenFiles();
                        for (P4FileAction action : opened) {
                            if (action.getChangeList() == clid.getChangeListId() &&
                                    filePathCopy.contains(action.getFile())) {
                                if (LOG.isDebugEnabled()) {
                                    LOG.debug("Ignoring move-to-changelist " + clid + " request for " +
                                            action.getFile());
                                }
                                filePathCopy.remove(action.getFile());
                            }
                        }
                    }

                    PendingUpdateState update = mgr.moveFilesToChangelist(
                            project, filePathCopy, source, clid);
                    if (update == null) {
                        return Collections.emptyList();
                    }
                    return Collections.singletonList(update);
                }
            });
        }
    }

    // TODO this method is kind of a hack.
    // This needs to be performed in a more robust manner, meaning
    // that there shouldn't need to be this integrity check in the
    // first place.  The system should be able to maintain the state
    // correctly on its own.
    public void checkLocalIntegrity() throws InterruptedException {
        connection.cacheQuery(new CacheQuery<Void>() {
            @Override
            public Void query(@NotNull final ClientCacheManager cacheManager) throws InterruptedException {
                cacheManager.checkLocalIntegrity();
                return null;
            }
        });
    }

    /**
     * Set by the owning manager.
     *
     * @param isValid valid state
     */
    void setValid(boolean isValid) {
        valid = isValid;
    }


    public void dispose() {
        disposed = true;
    }

    @NotNull
    public ClientServerRef getClientServerId() {
        return source.getClientServerRef();
    }

    @NotNull
    public ServerConfig getServerConfig() {
        return source.getServerConfig();
    }

    @Nullable
    public String getClientName() {
        return source.getClientName();
    }

    /**
     * Check if the given file is ignored by version control.
     *
     * @param fp file or directory to check
     * @return true if ignored, which includes directories.
     */
    public boolean isIgnored(@Nullable final FilePath fp) throws InterruptedException {
        if (fp == null || fp.isDirectory()) {
            return true;
        }
        return connection.cacheQuery(new CacheQuery<Boolean>() {
            @Override
            public Boolean query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                return mgr.isIgnored(fp);
            }
        });
    }

    /**
     * Fetch the file spec's contents.  If the file does not exist or is deleted,
     * it returns null.  If the filespec is invalid or the server is not connected,
     * an exception is thrown.
     *
     * @param spec file spec to read
     * @return the file contents, or null if it does not exist.
     * @throws P4DisconnectedException disconnected
     */
    @Nullable
    public String loadFileAsStringOnline(@NotNull final FilePath file, @NotNull final IFileSpec spec)
            throws P4DisconnectedException, InterruptedException {
        validateOnline();
        return connection.cacheQuery(new CacheQuery<String>() {
            @Override
            public String query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                return connection.query(project, RemoteFileReader.createStringReader(file, spec));
            }
        });
    }

    @Nullable
    public String loadFileAsStringOnline(@NotNull FilePath file, final int rev)
            throws P4DisconnectedException, InterruptedException {
        try {
            final IFileSpec spec = FileSpecUtil.getOneSpecWithRev(file, rev);
            return loadFileAsStringOnline(file, spec);
        } catch (P4Exception e) {
            alertManager.addWarning(project,
                    P4Bundle.message("exception.load-file.error.title"),
                    P4Bundle.message("exception.load-file.error", file),
                    e, file);
            return null;
        }
    }

    @Nullable
    public byte[] loadFileAsBytesOnline(@NotNull final FilePath file, @NotNull final IFileSpec spec)
            throws P4DisconnectedException, InterruptedException {
        validateOnline();
        return connection.cacheQuery(new CacheQuery<byte[]>() {
            @Override
            public byte[] query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                return connection.query(project, RemoteFileReader.createByteReader(file, spec));
            }
        });
    }

    @Nullable
    public byte[] loadFileAsBytesOnline(@NotNull FilePath file, final int rev)
            throws P4DisconnectedException, InterruptedException {
        try {
            final IFileSpec spec = FileSpecUtil.getOneSpecWithRev(file, rev);
            return loadFileAsBytesOnline(file, spec);
        } catch (P4Exception e) {
            alertManager.addWarning(project,
                    P4Bundle.message("exception.load-file.error.title"),
                    P4Bundle.message("exception.load-file.error", file),
                    e, file);
            return null;
        }
    }

    public void deleteFiles(@NotNull final List<FilePath> files, final int changelistId) {
        if (files.isEmpty()) {
            return;
        }
        connection.queueUpdates(project, new CreateUpdate() {
            @NotNull
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                List<PendingUpdateState> ret = new ArrayList<PendingUpdateState>(files.size());
                for (FilePath file : files) {
                    PendingUpdateState update = mgr.deleteFile(project, file, changelistId);
                    if (update != null) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug("Created delete update for " + file);
                        }
                        ret.add(update);
                    } else {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug("Ignored delete update for " + file);
                        }
                    }
                }
                return ret;
            }
        });
    }

    public void submitChangelistOnline(@NotNull final List<FilePath> files,
            @NotNull final List<P4ChangeListJob> jobs,
            @Nullable final String submitStatus, final int changeListId,
            @Nullable final String comment, @NotNull final Ref<List<P4StatusMessage>> results,
            @NotNull final Ref<VcsException> problem)
            throws P4DisconnectedException, InterruptedException {
        validateOnline();
        connection.cacheQuery(new CacheQuery<Void>() {
            @Override
            public Void query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                ServerUpdateAction action = mgr.submitChangelistOnline(
                        files, jobs, submitStatus, changeListId, comment, results, problem);
                if (action != null) {
                    connection.runImmediately(project, action);
                }
                return null;
            }
        });
    }

    public static class ShelveFileResult {
        private final P4ChangeListId shelvedChangelist;
        private final MessageResult<List<IFileSpec>> shelvedFiles;
        private final boolean failed;

        ShelveFileResult(P4ChangeListId shelvedChangelist,
                MessageResult<List<IFileSpec>> shelvedFiles, boolean failed) {
            LOG.info("Shelved " + (shelvedChangelist == null ? null : shelvedChangelist.getChangeListId()) + ": " +
                    shelvedFiles);
            this.shelvedChangelist = shelvedChangelist;
            this.shelvedFiles = shelvedFiles;
            this.failed = failed;
        }

        public boolean hasShelvedFiles() {
            return (! isError() && ! shelvedFiles.getResult().isEmpty());
        }

        public boolean isError() {
            return failed || shelvedFiles.isError();
        }

        public P4ChangeListId getChangelistId() {
            return shelvedChangelist;
        }
    }

    /**
     * Shelves the files in the changelist.  If the changelist is the default changelist, then a
     * new changelist is created with the given description, and the files are shelved in that one.
     *
     * @param changeList changelist to shelve
     * @param newChangelistNameIfNeeded description if the changelist is the default changelist.
     * @return results
     * @throws P4DisconnectedException if the server is disconnected
     * @throws InterruptedException if the action is interrupted
     */
    @NotNull
    public ShelveFileResult shelveFilesInChangelistForOnline(
            @NotNull final P4ChangeListId changeList,
            @NotNull final String newChangelistNameIfNeeded)
            throws P4DisconnectedException, InterruptedException {
        return shelveFilesInChangelistForOnline(changeList, newChangelistNameIfNeeded, null);
    }


    /**
     * Shelves the files in the changelist.  If the changelist is the default changelist, then a
     * new changelist is created with the given description, and the files are shelved in that one.
     *
     * @param changeList changelist to shelve
     * @param newChangelistNameIfNeeded description if the changelist is the default changelist.
     * @param files files to shelve; null for all the files in the changelist.
     * @return results
     * @throws P4DisconnectedException if the server is disconnected
     * @throws InterruptedException if the action is interrupted
     */
    @NotNull
    public ShelveFileResult shelveFilesInChangelistForOnline(
            @NotNull final P4ChangeListId changeList,
            @NotNull final String newChangelistNameIfNeeded,
            @Nullable final List<FilePath> files)
            throws P4DisconnectedException, InterruptedException {
        validateOnline();
        ShelveFileResult ret =
                connection.query(project, new ServerQuery<ShelveFileResult>() {
                    @Nullable
                    @Override
                    public ShelveFileResult query(@NotNull P4Exec2 exec,
                            @NotNull ClientCacheManager cacheManager,
                            @NotNull ServerConnection connection, @NotNull SynchronizedActionRunner runner,
                            @NotNull AlertManager alerts)
                            throws InterruptedException {
                        try {
                            List<IFileSpec> fileSpecs = null;
                            if (files != null) {
                                fileSpecs = FileSpecUtil.getFromFilePaths(files);
                            }
                            // TODO this might need to run through the changelist cache instead.
                            int changelistId = changeList.getChangeListId();
                            if (changeList.isDefaultChangelist()) {
                                LOG.info("Creating changelist for shelve, because invoked with default changelist");
                                List<IFileSpec> filesToReopen = new ArrayList<IFileSpec>();
                                if (files == null) {
                                    List<Pair<IExtendedFileSpec, IExtendedFileSpec>> openedFiles =
                                            exec.getFileStatusForChangelist(IChangelist.DEFAULT, true);
                                    if (LOG.isDebugEnabled()) {
                                        LOG.debug("Files in default changelist: " + openedFiles);
                                    }
                                    for (Pair<IExtendedFileSpec, IExtendedFileSpec> file : openedFiles) {
                                        if (file.first != null) {
                                            filesToReopen.add(file.first);
                                        }
                                        if (file.second != null) {
                                            filesToReopen.add(file.second);
                                        }
                                    }
                                } else {
                                    filesToReopen = fileSpecs;
                                }
                                IChangelist newChange = exec.createChangeList(newChangelistNameIfNeeded);
                                changelistId = newChange.getId();
                                LOG.info("Moving files to changelist " + changelistId + ": " + filesToReopen);
                                exec.reopenFiles(filesToReopen, changelistId, null);
                            }
                            return new ShelveFileResult(
                                    new P4ChangeListIdImpl(getClientServerId(), changelistId),
                                    MessageResult.create(exec.shelveFilesForChangelist(changelistId, fileSpecs)),
                                    false);
                        } catch (VcsException e) {
                            alerts.addWarning(exec.getProject(),
                                    P4Bundle.message("error.shelve-files-changelist.title"),
                                    P4Bundle.message("error.shelve-files-changelist", changeList.getChangeListId()),
                                    e,
                                    new FilePath[0]);
                            return null;
                        }
                    }
                });
        if (ret == null) {
            ret = new ShelveFileResult(null, null, true);
        }
        return ret;
    }

    @NotNull
    public List<P4AnnotatedLine> getAnnotationsForOnline(@NotNull final FilePath baseFile,
            @NotNull final IFileSpec spec, final int revNumber)
            throws VcsException, InterruptedException {
        validateOnline();
        final Ref<VcsException> ex = new Ref<VcsException>();
        final List<P4AnnotatedLine> ret = connection.query(project, new ServerQuery<List<P4AnnotatedLine>>() {
            @Nullable
            @Override
            public List<P4AnnotatedLine> query(@NotNull final P4Exec2 exec,
                    @NotNull final ClientCacheManager cacheManager,
                    @NotNull final ServerConnection connection,
                    @NotNull final SynchronizedActionRunner runner,
                    @NotNull final AlertManager alerts)
                    throws InterruptedException {
                try {
                    IFileSpec usedSpec = spec;
                    if (revNumber > 0) {
                        usedSpec = FileSpecUtil.getAlreadyEscapedSpec(spec.getDepotPathString() + '#' + revNumber);
                    }
                    return P4AnnotatedLine.loadAnnotatedLines(exec, baseFile,
                            exec.getAnnotationsFor(Collections.singletonList(usedSpec)));
                } catch (VcsException e) {
                    ex.set(e);
                    return null;
                }
            }
        });
        if (! ex.isNull()) {
            throw ex.get();
        }
        if (ret == null) {
            throw new P4FileException(spec.getDepotPathString());
        }
        return ret;
    }

    @Nullable
    public List<P4FileRevision> getRevisionHistoryOnline(@NotNull final IExtendedFileSpec spec,
            final int limit) throws InterruptedException {

        // TODO this is too complex for this class; move to another.

        return connection.query(project, new ServerQuery<List<P4FileRevision>>() {
            @Nullable
            @Override
            public List<P4FileRevision> query(@NotNull final P4Exec2 exec,
                    @NotNull final ClientCacheManager cacheManager,
                    @NotNull final ServerConnection connection,
                    @NotNull final SynchronizedActionRunner runner,
                    @NotNull final AlertManager alerts)
                    throws InterruptedException {

                // FIXME there's a bug here where getting the revision for a file with a special character won't return any history.  e.g.
                // //depot/projecta/hotfix/a/test%23one.txt returns map {null=null}

                Map<IFileSpec, List<IFileRevisionData>> history;
                try {
                    history = exec.getRevisionHistory(Collections.<IFileSpec>singletonList(spec), limit);
                } catch (VcsException e) {
                    alerts.addNotice(project,
                            P4Bundle.message("error.revision-history", spec.getDepotPathString()), e);
                    return null;
                }
                LOG.info("history for " + spec.getDepotPathString() + ": " + history);

                List<P4FileRevision> ret = new ArrayList<P4FileRevision>();
                for (Entry<IFileSpec, List<IFileRevisionData>> entry : history.entrySet()) {
                    if (entry.getValue() == null) {
                        LOG.info("history for " + spec.getDepotPathString() + ": null values for " + entry.getKey());
                    } else {
                        for (IFileRevisionData rev : entry.getValue()) {
                            if (rev != null) {
                                final P4FileRevision p4rev = createRevision(
                                        FilePathUtil.getFilePath(spec.getClientPathString()),
                                        entry.getKey(), rev, alerts);
                                if (p4rev != null) {
                                    ret.add(p4rev);
                                }
                            }
                        }
                    }
                }

                // Note that these are not sorted.  Sort by date.
                Collections.sort(ret, REV_COMPARE);

                return ret;
            }
        });
    }

    @Nullable
    public P4CommittedChangeList getChangelistForOnline(@NotNull final FilePath file, @NotNull final String revision)
            throws InterruptedException {
        P4CommittedChangeList.Factory ret = connection.query(project, new ServerQuery<P4CommittedChangeList.Factory>() {
            @Nullable
            @Override
            public P4CommittedChangeList.Factory query(@NotNull final P4Exec2 exec,
                    @NotNull final ClientCacheManager cacheManager,
                    @NotNull final ServerConnection connection,
                    @NotNull final SynchronizedActionRunner runner,
                    @NotNull final AlertManager alerts)
                    throws InterruptedException {
                final List<IFileSpec> specs;
                try {
                    final MessageResult<List<IFileSpec>> result = MessageResult.create(
                            FileSpecUtil
                                    .getFromFilePathsAt(Collections.singletonList(file), revision, false));
                    specs = result.getResult();
                } catch (P4Exception e) {
                    alertManager.addWarning(project,
                            P4Bundle.message("exception.filespec.title"),
                            P4Bundle.message("exception.filespec", revision),
                            e, file);
                    return null;
                }
                if (specs.size() != 1) {
                    LOG.warn("Changelist for " + file + " returned invalid spec count: " + specs);
                    return null;
                }
                final List<IExtendedFileSpec> status;
                try {
                    status = MessageResult.create(exec.getFileStatus(specs)).getResult();
                } catch (VcsException e) {
                    alertManager.addWarning(project,
                            P4Bundle.message("exception.filespec.title"),
                            P4Bundle.message("exception.filespec", revision),
                            e, file);
                    return null;
                }
                if (status.size() != 1) {
                    LOG.warn("Status for specs " + specs + " returned invalid status count: " + status);
                    return null;
                }

                // p4 fstat on a specific rev returns all the status
                // in the "HeadX" field.  See bug #86.
                int change = status.get(0).getHeadChange();
                if (change <= 0) {
                    change = status.get(0).getChangelistId();
                    if (change <= 0) {
                        LOG.warn("FileStat for " + file + " rev " + revision
                                + " has invalid changelist number; " +
                                status);
                        return null;
                    }
                }
                return getInnerChangelistForOnline(exec, change, new FilePath[] { file });
            }
        });
        if (ret != null) {
            return ret.create(alertManager);
        }
        return null;
    }

    @Nullable
    public P4CommittedChangeList getChangelistForOnline(final int change)
            throws InterruptedException {
        P4CommittedChangeList.Factory ret = connection.query(project, new ServerQuery<P4CommittedChangeList.Factory>() {
            @Nullable
            @Override
            public P4CommittedChangeList.Factory query(@NotNull final P4Exec2 exec,
                    @NotNull final ClientCacheManager cacheManager,
                    @NotNull final ServerConnection connection,
                    @NotNull final SynchronizedActionRunner runner,
                    @NotNull final AlertManager alerts)
                    throws InterruptedException {
                return getInnerChangelistForOnline(exec, change, new FilePath[0]);
            }
        });
        if (ret != null) {
            return ret.create(alertManager);
        }
        return null;
    }

    @Nullable
    private P4CommittedChangeList.Factory getInnerChangelistForOnline(@NotNull P4Exec2 exec, int change,
            @NotNull FilePath[] file)
            throws InterruptedException {
        final IChangelist changelist;
        List<Pair<IExtendedFileSpec, IExtendedFileSpec>> changelistFiles;
        try {
            changelist = exec.getChangelist(change);
            if (changelist == null) {
                return null;
            }
            changelistFiles = exec.getFileStatusForChangelist(changelist.getId(), false);
        } catch (VcsException e) {
            alertManager.addWarning(project,
                    P4Bundle.message("exception.changelist-fetch", change),
                    P4Bundle.message("exception.changelist-fetch", change),
                    e, file);
            return null;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug("Returning committed changelist for " +
                    changelist.getId() + ": " + changelistFiles);
        }
        return new P4CommittedChangeList.Factory(P4Vcs.getInstance(project), P4Server.this,
                changelist, changelistFiles);
    }

    @NotNull
    public List<P4CommittedChangeList> getChangelistsForOnline(@NotNull final IFileSpec spec, final int maxCount)
            throws InterruptedException {
        List<P4CommittedChangeList> ret = connection.query(project, new ServerQuery<List<P4CommittedChangeList>>() {
            @Override
            public List<P4CommittedChangeList> query(@NotNull P4Exec2 exec, @NotNull ClientCacheManager cacheManager,
                    @NotNull ServerConnection connection, @NotNull SynchronizedActionRunner runner,
                    @NotNull AlertManager alerts)
                    throws InterruptedException {
                P4Vcs vcs = P4Vcs.getInstance(project);
                try {
                    List<IChangelistSummary> changes = exec.getChangelists(spec, maxCount);
                    List<P4CommittedChangeList> ret = new ArrayList<P4CommittedChangeList>(changes.size());
                    for (IChangelistSummary change : changes) {
                        ret.add(new P4CommittedChangeList(vcs, change));
                    }
                    return ret;
                } catch (VcsException e) {
                    alertManager.addWarning(project,
                            P4Bundle.message("exception.changelist-list-fetch"),
                            P4Bundle.message("exception.changelist-list-fetch"),
                            e, Collections.singletonList(spec));
                    return Collections.emptyList();
                }
            }
        });
        return ret == null ? Collections.<P4CommittedChangeList>emptyList() : ret;
    }

    @NotNull
    public Collection<String> getJobStatusValues() throws InterruptedException {
        final Collection<String> ret = connection.cacheQuery(new CacheQuery<Collection<String>>() {
            @Override
            public Collection<String> query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                if (isWorkingOnline()) {
                    connection.query(project, mgr.createJobStatusListRefreshQuery());
                }
                return mgr.getCachedJobStatusList();
            }
        });
        if (ret == null) {
            return Collections.emptyList();
        }
        return ret;
    }

    @NotNull
    public Map<String, P4ChangeListJob> getJobsForIds(@NotNull final Collection<String> jobId) throws InterruptedException {
        if (jobId.isEmpty()) {
            return Collections.emptyMap();
        }
        return connection.cacheQuery(new CacheQuery<Map<String, P4ChangeListJob>>() {
            @Override
            public Map<String, P4ChangeListJob> query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                if (isWorkingOnline()) {
                    connection.query(project, mgr.createJobRefreshQuery(jobId));
                }
                return mgr.getCachedJobIds(jobId);
            }
        });
    }


    @NotNull
    public Collection<P4ChangeListJob> getJobsInChangelistForOnline(final int changelistId)
            throws InterruptedException {
        if (changelistId <= 0) {
            return Collections.emptyList();
        }
        Collection<P4ChangeListJob> ret = connection.query(project, new ServerQuery<Collection<P4ChangeListJob>>() {
            @Nullable
            @Override
            public Collection<P4ChangeListJob> query(@NotNull P4Exec2 exec, @NotNull ClientCacheManager cacheManager,
                    @NotNull ServerConnection connection, @NotNull SynchronizedActionRunner runner,
                    @NotNull AlertManager alerts)
                    throws InterruptedException {
                try {
                    Collection<String> jobIds = exec.getJobIdsForChangelist(changelistId);
                    if (jobIds == null) {
                        return Collections.emptyList();
                    }
                    List<P4ChangeListJob> ret = new ArrayList<P4ChangeListJob>(jobIds.size());
                    for (String jobId : jobIds) {
                        P4JobState job = exec.getJobForId(jobId);
                        if (job != null) {
                            ret.add(new P4ChangeListJob(getClientServerId(), job));
                        }
                    }
                    return ret;
                } catch (VcsException e) {
                    alertManager.addWarning(project,
                            P4Bundle.message("exception.job-fetch"),
                            P4Bundle.message("exception.job-fetch"),
                            e, new FilePath[0]);
                    return Collections.emptyList();
                }
            }
        });
        if (ret == null) {
            return Collections.emptyList();
        }
        return ret;
    }


    @NotNull
    public Collection<P4ChangeListJob> getJobsInChangelists(@NotNull final Collection<P4ChangeListId> changes)
            throws InterruptedException {
        final Collection<P4ChangeListJob> ret = connection.cacheQuery(new CacheQuery<Collection<P4ChangeListJob>>() {
            @Override
            public Collection<P4ChangeListJob> query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                if (isWorkingOnline()) {
                    connection.query(project, mgr.createChangeListRefreshQuery());
                }
                return mgr.getCachedJobsInChangelists(changes);
            }
        });
        if (ret == null) {
            return Collections.emptyList();
        }
        return ret;
    }

    public void forceWorkspaceRefresh() throws InterruptedException {
        connection.cacheQuery(new CacheQuery<Void>() {
            @Override
            public Void query(@NotNull final ClientCacheManager mgr) throws InterruptedException {
                if (isWorkingOnline()) {
                    LOG.debug("working online; forcing a workspace refresh");
                    connection.query(project, mgr.createForcedWorkspaceRefreshQuery());
                } else {
                    LOG.debug("working offline; using cached workspace settings.");
                }
                return null;
            }
        });
    }

    /**
     * Find all the virtual files that are different than the server's
     * have version.  If we're working online, we first check what the
     * "have" version is, otherwise we assume the P4FileSyncState is
     * correct.  If we have a P4FileSyncState, then that is used to
     * determine the MD5.
     *
     * @param files list of files idea thinks are different.
     * @return actually different files
     */
    @NotNull
    public List<VirtualFile> getVirtualFilesDifferentThanServerHaveVersionOnline(
            @NotNull final List<VirtualFile> files) throws InterruptedException {
        final Map<VirtualFile, P4FileSyncState> syncState =
                connection.cacheQuery(new CacheQuery<Map<VirtualFile, P4FileSyncState>>() {
                @Override
                public Map<VirtualFile, P4FileSyncState> query(@NotNull final ClientCacheManager mgr)
                        throws InterruptedException {
                    if (isWorkingOnline()) {
                        return connection.query(project, mgr.createHaveFileRefreshQuery(files));
                    } else {
                        return mgr.getCachedHaveVersions(files);
                    }
                }
            });
        return getFilesDifferentThanServerOnline(syncState);
    }

    @Override
    public String toString() {
        return getClientServerId().toString();
    }

    /**
     *
     * @return source for the config
     */
    @NotNull
    public ClientConfig getClientConfig() {
        return source;
    }

    @Nullable
    public SwarmConfig createSwarmConfig()
            throws InterruptedException {
        return connection.query(project, new ServerQuery<SwarmConfig>() {
            @Nullable
            @Override
            public SwarmConfig query(@NotNull P4Exec2 exec, @NotNull ClientCacheManager cacheManager,
                    @NotNull ServerConnection connection, @NotNull SynchronizedActionRunner runner,
                    @NotNull AlertManager alerts)
                    throws InterruptedException {
                try {
                    return exec.createSwarmConfigSettings();
                } catch (VcsException e) {
                    LOG.warn("Problem finding swarm configuration for " + exec.getServerConfig(), e);
                    return null;
                }
            }
        });
    }

    public void flushCache(boolean includeLocal, boolean force) throws InterruptedException {
        connection.flushCache(project, includeLocal, force);
    }


    private static void addPendingUpdateState(@NotNull final List<PendingUpdateState> updates,
            @Nullable final PendingUpdateState pendingUpdateState) {
        if (pendingUpdateState != null) {
            updates.add(pendingUpdateState);
        }
    }


    private void validateOnline() throws P4DisconnectedException {
        if (isWorkingOffline()) {
            P4DisconnectedException ex = new P4DisconnectedException();
            alertManager.addCriticalError(new DisconnectedHandler(project, connection.getServerConnectedController(),
                    ex), ex);
            throw ex;
        }
    }


    @NotNull
    private static Collection<PendingUpdateState> singlePendingUpdateState(
            @Nullable final PendingUpdateState pendingUpdateState) {
        if (pendingUpdateState == null) {
            return Collections.emptyList();
        }
        return Collections.singleton(pendingUpdateState);
    }


    @Nullable
    private P4FileRevision createRevision(@NotNull FilePath baseFile, @NotNull IFileSpec spec,
            @NotNull final IFileRevisionData rev, final AlertManager alerts) {
        if (spec.getDepotPathString() == null && rev.getDepotFileName() == null) {
            alerts.addNotice(project, P4Bundle.message("error.revision-null", spec), null,
                    FilePathUtil.getFilePath(spec.getClientPathString()));
            return null;
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug("Finding location of " + spec);
        }
        // Note: check above performs the NPE checks.
        return new P4FileRevision(project, getClientServerId(),
                baseFile, spec.getDepotPathString(), rev.getDepotFileName(), rev);
    }

    private static final RevCompare REV_COMPARE = new RevCompare();

    // Comparator must implement Serializable
    private static class RevCompare implements Comparator<P4FileRevision>, Serializable {
        @Override
        public int compare(final P4FileRevision o1, final P4FileRevision o2) {
            // compare in reverse order
            return o2.getRevisionDate().compareTo(o1.getRevisionDate());
        }
    }

    @NotNull
    private List<VirtualFile> getFilesDifferentThanServerOnline(@NotNull final Map<VirtualFile, P4FileSyncState> syncState)
            throws InterruptedException {
        // Check the virtual files' MD5 against the cached server MD5.

        List<VirtualFile> ret = new ArrayList<VirtualFile>(syncState.size());
        for (Entry<VirtualFile, P4FileSyncState> entry : syncState.entrySet()) {
            final VirtualFile vf = entry.getKey();
            String vfMd5;
            try {
                vfMd5 = readMd5(entry.getKey());
            } catch (IOException e) {
                alertManager.addWarning(project,
                        P4Bundle.message("error.read-file.title"),
                        P4Bundle.message("error.read-file", vf),
                        e, new VirtualFile[] { vf });
                ret.add(vf);
                continue;
            }
            String fsMd5 = entry.getValue().getMd5();
            if (fsMd5 == null) {
                final IFileSpec spec;
                try {
                    spec = entry.getValue().getFileSpec();
                } catch (P4Exception e) {
                    alertManager.addWarning(project,
                            P4Bundle.message("exception.filespec.title"),
                            P4Bundle.message("exception.filespec", vf),
                            e, new VirtualFile[]{ vf });
                    ret.add(entry.getKey());
                    continue;
                }
                LOG.info("Gathering server MD5 for " + spec);
                fsMd5 = connection.query(project, new ServerQuery<String>() {
                    @Nullable
                    @Override
                    public String query(@NotNull final P4Exec2 exec,
                            @NotNull final ClientCacheManager cacheManager,
                            @NotNull final ServerConnection connection,
                            @NotNull final SynchronizedActionRunner runner,
                            @NotNull final AlertManager alerts)
                            throws InterruptedException {
                        try {
                            return exec.loadMd5For(spec);
                        } catch (VcsException e) {
                            alertManager.addWarning(project,
                                    P4Bundle.message("error.read-server-file.title"),
                                    P4Bundle.message("error.read-server-file", vf),
                                    e, new VirtualFile[]{ vf });
                            return null;
                        }
                    }
                });
                entry.getValue().setMd5(fsMd5);
            }
            // Includes null check
            if (! vfMd5.equals(fsMd5)) {
                ret.add(entry.getKey());
            }
        }
        return ret;
    }


    private static final int BUFFER_SIZE = 4 * 1024;
    @NotNull
    private static String readMd5(@NotNull VirtualFile vf) throws IOException {
        final MD5Digester digester = new MD5Digester();
        InputStream in = vf.getInputStream();
        try {
            byte[] buff = new byte[BUFFER_SIZE];
            int len;
            while ((len = in.read(buff, 0, BUFFER_SIZE)) > 0) {
                digester.update(buff, 0, len);
            }
        } finally {
            in.close();
        }
        return digester.digestAs32ByteHex();
    }

}
